# SOME DESCRIPTIVE TITLE.
# Copyright (C) Game Manual 0 Contributors |  Hosting Graciously Provided By //Copperforge
# This file is distributed under the same license as the Game Manual 0 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Marianq Lujan, 2024
# Yaretzi Lugo, 2024
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Game Manual 0 0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-11 04:15+0000\n"
"PO-Revision-Date: 2022-08-16 05:18+0000\n"
"Last-Translator: Yaretzi Lugo, 2024\n"
"Language-Team: Spanish (Mexico) (https://app.transifex.com/gamemanual0/teams/148648/es_MX/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es_MX\n"
"Plural-Forms: nplurals=3; plural=n == 1 ? 0 : n != 0 && n % 1000000 == 0 ? 1 : 2;\n"

#: ../../gm0/source/docs/software/concepts/odometry.rst:4
msgid "Odometry"
msgstr "Odometría"

#: ../../gm0/source/docs/software/concepts/odometry.rst:6
msgid ""
"Odometry is a form of localization that uses data from sensors like encoders"
" to derive an estimated position relative to a starting point. Localization "
"is a means for being able to locate the position of the bot at some point in"
" time. Odometry is especially useful in autonomous programs because it "
"allows for easier implementation of different tasks on the field due to "
"understanding one's position."
msgstr ""
"La odometría es una forma de localización que utiliza datos de sensores como"
" codificadores para obtener una posición estimada en relación con un punto "
"de partida. La localización es un medio para poder situar la posición del "
"robot en un momento dado. La odometría es especialmente útil en programas "
"autónomos porque permite realizar más fácilmente distintas tareas sobre el "
"terreno gracias a la comprensión de la propia posición."

#: ../../gm0/source/docs/software/concepts/odometry.rst:9
msgid "Pose"
msgstr "Pose"

#: ../../gm0/source/docs/software/concepts/odometry.rst:11
msgid ""
"We refer to pose, which is the position of some body (like a bot), normally "
"in the context two-dimensional space, as the movement of the robot is "
"generally constrained to a single plane. We notate the robot's pose as "
":math:`\\vec{x}`. A pose contains two entries: the robot's position and "
"heading; position is generally in Cartesian coordinates, so the pose can be "
"represented with :math:`x`, :math:`y`, and :math:`\\theta`. A \"heading\" is"
" a term for the direction towards which the front of the robot is facing. "
"Because of this, the robot's coordinate frame is set up such that the global"
" x-axis is lined up with the 0 heading."
msgstr ""
"Nos referimos a la pose, que es la posición de algún cuerpo (como un robot),"
" normalmente en el contexto del espacio bidimensional, ya que el movimiento "
"del robot está generalmente restringido a un solo plano. Anotamos la pose "
"del robot como :math:`\\vec{x}`. Una pose contiene dos entradas: la posición"
" y el rumbo del robot; la posición suele estar en coordenadas cartesianas, "
"por lo que la pose puede representarse con :math:`x`, :math:`y` y "
":math:`\\theta`. Un \"rumbo\" es un término para la dirección hacia la que "
"está orientada la parte frontal del robot. Debido a esto, el marco de "
"coordenadas del robot está configurado de tal forma que el eje x global está"
" alineado con el rumbo 0."

#: ../../gm0/source/docs/software/concepts/odometry.rst:18
msgid "The directional axes of the robot with respect to its body"
msgstr "Los ejes direccionales del robot con respecto a su cuerpo"

#: ../../gm0/source/docs/software/concepts/odometry.rst:18
msgid ""
"`Road Runner Coordinate Frame Documentation <https://acme-"
"robotics.gitbook.io/road-runner/tour/coordinate-frame>`_"
msgstr ""
"`Road Runner Documentación del Marco de Coordenadas <https://acme-"
"robotics.gitbook.io/road-runner/tour/coordinate-frame>`_"

#: ../../gm0/source/docs/software/concepts/odometry.rst:20
msgid ""
"We can refer to the current pose (:math:`\\vec{x}_0`) of the robot as "
":math:`\\begin{pmatrix} x_0 \\\\ y_0 \\\\ \\theta_0 \\end{pmatrix}`. This is"
" just fancy notation for a point on the field :math:`(x_0, y_0)` with a "
"specified orientation of the robot--the heading :math:`\\theta_0`. A pose "
"generally has some beginning origin in the coordinate frame."
msgstr ""
"Podemos referirnos a la pose actual (:math:`\\vec{x}_0`) del robot como "
":math:`\\begin{pmatrix} x_0 \\ y_0 \\\\theta_0 \\end{pmatrix}`. Esto es sólo"
" una notación de fantasía para un punto en el campo :math:`(x_0, y_0)` con "
"una orientación especificada del robot--el rumbo :math:`\\theta_0`. Una pose"
" generalmente tiene un origen inicial en el marco de coordenadas."

#: ../../gm0/source/docs/software/concepts/odometry.rst:23
msgid "Updating the Pose"
msgstr "Actualizar la pose"

#: ../../gm0/source/docs/software/concepts/odometry.rst:25
msgid ""
"The change in pose over some very small amount of time is :math:`\\Delta "
"\\vec{x}`. The difference in time between the current pose and the last pose"
" should be as small as possible to improve the approximations for the math. "
"Teams should update their robot pose every cycle of their control loop."
msgstr ""
"El cambio de pose a lo largo de un periodo de tiempo muy pequeño es "
":math:`\\Delta \\vec{x}`. La diferencia de tiempo entre la pose actual y la "
"última pose debe ser lo más pequeña posible para mejorar las aproximaciones "
"matemáticas. Los equipos deben actualizar la pose de su robot en cada ciclo "
"de su bucle de control."

#: ../../gm0/source/docs/software/concepts/odometry.rst:27
msgid ""
"Updating the pose is as simple as adding the transformed change to the "
"previous pose where :math:`\\varphi = \\Delta\\theta`"
msgstr ""
"Actualizar la pose es tan sencillo como añadir el cambio transformado a la "
"pose anterior donde :math:`\\varphi = \\Delta\\theta`"

#: ../../gm0/source/docs/software/concepts/odometry.rst:29
msgid ""
"\\begin{pmatrix}\n"
"   x \\\\\n"
"   y \\\\\n"
"   \\theta\n"
"\\end{pmatrix} =\n"
"\\begin{pmatrix}\n"
"   x_0 \\\\\n"
"   y_0\\\\\n"
"   \\theta_0\n"
"\\end{pmatrix} +\n"
"\\begin{pmatrix}\n"
"   \\Delta x \\\\\n"
"   \\Delta y \\\\\n"
"   \\varphi\n"
"\\end{pmatrix}"
msgstr ""
"\\empezar{pmatrix}\n"
"   x \\\\\n"
"   y \\\\\n"
"   \\theta\n"
"\\fin{pmatrix} =\n"
"\\Inicio{pmatrix}\n"
"   x_0 \\\\\n"
"   y_0\\\\\n"
"   \\theta_0\n"
"\\end{pmatrix} +\n"
"\\Inicio{pmatrix}\n"
"   \\Delta x\n"
"   \\Delta y\n"
"   \\varphi\n"
"\\fin{pmatrix}"

#: ../../gm0/source/docs/software/concepts/odometry.rst:47
msgid ""
"The idea of odometry is to use sensor data and math to form an approximation"
" for the robot's pose over time."
msgstr ""
"La idea de la odometría es utilizar los datos de los sensores y las "
"matemáticas para formar una aproximación de la pose del robot a lo largo del"
" tiempo."

#: ../../gm0/source/docs/software/concepts/odometry.rst:50
msgid "Finding the Change in Position"
msgstr "Determinación del cambio de posición"

#: ../../gm0/source/docs/software/concepts/odometry.rst:52
msgid ""
"In order to determine the current location of the robot and update its pose,"
" the change must be calculated using data read from the sensors. For a "
"robot, there will be three possible sensors that you can use: two that are "
"parallel with the robot's body in the :math:`x`-direction and one that is "
"aligned with the :math:`y`-direction of movement (perpendicular to the drive"
" wheels)."
msgstr ""
"Para determinar la posición actual del robot y actualizar su pose, el cambio"
" debe calcularse utilizando los datos leídos de los sensores. Para un robot,"
" habrá tres sensores posibles que se pueden utilizar: dos que son paralelos "
"al cuerpo del robot en la dirección :math:`x` y uno que está alineado con la"
" dirección de movimiento :math:`y` (perpendicular a las ruedas motrices)."

#: ../../gm0/source/docs/software/concepts/odometry.rst:55
msgid "Angle and Displacement"
msgstr "Ángulo y desplazamiento"

#: ../../gm0/source/docs/software/concepts/odometry.rst:57
msgid ""
"The displacement (or change in position) of the left sensor is "
":math:`\\Delta x_l` and the displacement of the right sensor is "
":math:`\\Delta x_r`. The lateral distance between these two sensors is "
"called the trackwidth, notated as :math:`L`. This is very important for "
"determining angle for turning approximations. This value will need to be "
"tuned, which means tested repeatedly and then brought to some converging "
"value that is close to the actual measurement."
msgstr ""
"El desplazamiento (o cambio de posición) del sensor izquierdo es "
":math:`\\Delta x_l` y el desplazamiento del sensor derecho es :math:`\\Delta"
" x_r`. La distancia lateral entre estos dos sensores se denomina ancho de "
"vía, anotada como :math:`L`. Esto es muy importante para determinar el "
"ángulo para aproximaciones de giro. Este valor tendrá que ser sintonizado, "
"lo que significa probado repetidamente y luego llevado a algún valor "
"convergente que esté cerca de la medición real."

#: ../../gm0/source/docs/software/concepts/odometry.rst:62
msgid "The lateral distance, forward offset, and location of the sensors"
msgstr ""
"La distancia lateral, el desplazamiento hacia delante y la ubicación de los "
"sensores"

#: ../../gm0/source/docs/software/concepts/odometry.rst:62
msgid ""
"`17508 Rising Tau's 2019/20 Skystone Bot <https://learnroadrunner.com/dead-"
"wheels.html#three-wheel-odometry>`_"
msgstr ""
"`17508 Rising Tau's 2019/20 Skystone Bot <https://learnroadrunner.com/dead-"
"wheels.html#three-wheel-odometry>`_"

#: ../../gm0/source/docs/software/concepts/odometry.rst:64
msgid "Deriving the value of :math:`\\varphi` then becomes simple:"
msgstr ""
"Derivar el valor de :math:`\\varphi` se convierte entonces en algo sencillo:"

#: ../../gm0/source/docs/software/concepts/odometry.rst:66
msgid ""
"\\varphi = \\frac{\\Delta x_l - \\Delta x_r}{L}\n"
"\n"
msgstr ""
"\\varphi = \\frac{\\Delta x_l - \\Delta x_r}{L}\n"
"\n"

#: ../../gm0/source/docs/software/concepts/odometry.rst:68
msgid ""
"To perform later calculations, we need to know the displacement of the robot"
" in the x-direction relative to its center rather than the two parallel "
"sensors. To do this, we take the average to derive :math:`\\Delta x_c`, or "
"the center displacement:"
msgstr ""
"Para realizar los cálculos posteriores, necesitamos conocer el "
"desplazamiento del robot en la dirección x respecto a su centro y no "
"respecto a los dos sensores paralelos. Para ello, tomamos la media para "
"obtener :math:`\\Delta x_c`, o el desplazamiento central:"

#: ../../gm0/source/docs/software/concepts/odometry.rst:70
msgid ""
"\\Delta x_c = \\frac{\\Delta x_l + \\Delta x_r}{2}\n"
"\n"
msgstr ""
"\\Delta x_c = \\frac{\\Delta x_l + \\Delta x_r}{2}\n"
"\n"

#: ../../gm0/source/docs/software/concepts/odometry.rst:72
msgid ""
"The final displacement we need before we can determine the change in pose is"
" the horizontal displacement :math:`\\Delta x_\\perp`. This is the "
"displacement of the perpendicular sensor :math:`\\Delta x_h` with a "
"correction for forward offset :math:`F`. In order to get accurate "
"approximations, the forward offset needs to be considered. When the sensor "
"is closer to the back, the offset is negative, but when it is closer to the "
"front, it is positive. This is to account for the change in its position "
"based on point-turns."
msgstr ""
"El desplazamiento final que necesitamos antes de poder determinar el cambio "
"de pose es el desplazamiento horizontal :math:`\\Delta x_\\perp`. Este es el"
" desplazamiento del sensor perpendicular :math:`\\Delta x_h` con una "
"corrección por desplazamiento hacia delante :math:`F`. Para obtener "
"aproximaciones precisas, es necesario tener en cuenta el desplazamiento "
"hacia delante. Cuando el sensor está más cerca de la parte trasera, el "
"desplazamiento es negativo, pero cuando está más cerca de la parte "
"delantera, es positivo. Esto es para tener en cuenta el cambio en su "
"posición basado en puntos de giro."

#: ../../gm0/source/docs/software/concepts/odometry.rst:74
msgid "As a result of this, we can define our horizontal displacement as:"
msgstr ""
"Como resultado de esto, podemos definir nuestro desplazamiento horizontal "
"como:"

#: ../../gm0/source/docs/software/concepts/odometry.rst:76
msgid ""
"\\Delta x_\\perp = \\Delta x_h - (F * \\varphi)\n"
"\n"
msgstr ""
"\\Delta x_\\perp = \\Delta x_h - (F * \\varphi)\n"
"\n"

#: ../../gm0/source/docs/software/concepts/odometry.rst:80
msgid ""
"If you do not have perpendicular sensors, which are not required if the "
"robot cannot move in the lateral direction, :math:`\\Delta x_\\perp` is not "
"necessary."
msgstr ""
"Si no tiene sensores perpendiculares, que no son necesarios si el robot no "
"puede moverse en la dirección lateral, :math:`\\Delta x_\\perp` no es "
"necesario."

#: ../../gm0/source/docs/software/concepts/odometry.rst:82
msgid "For this value, use 0 if you do not have a horizontal sensor."
msgstr "Para este valor, utilice 0 si no dispone de sensor horizontal."

#: ../../gm0/source/docs/software/concepts/odometry.rst:85
msgid "Robot-Relative Deltas"
msgstr "Deltas relativos a robots"

#: ../../gm0/source/docs/software/concepts/odometry.rst:87
msgid ""
"Let's come up with a simplified, nonoptimal way to calculate our robot-"
"relative pose deltas which we can then transform into field-relative "
"coordinate changes. To perform this we need to transform the robot-relative "
"deltas via a rotation matrix where we rotate the relative pose difference by"
" the original heading. We can derive the values of :math:`\\Delta x` and "
":math:`\\Delta y`."
msgstr ""
"Vamos a idear una forma simplificada y no óptima de calcular los deltas de "
"la pose relativa de nuestro robot, que luego podremos transformar en cambios"
" de coordenadas relativos al campo. Para ello, tenemos que transformar los "
"deltas relativos al robot a través de una matriz de rotación donde giramos "
"la diferencia de pose relativa por el rumbo original. Podemos obtener los "
"valores de :math:`\\Delta x` y :math:`\\Delta y`."

#: ../../gm0/source/docs/software/concepts/odometry.rst:89
msgid ""
"\\begin{pmatrix}\n"
"   \\Delta x \\\\\n"
"   \\Delta y \\\\\n"
"   \\varphi\n"
"\\end{pmatrix} =\n"
"\\begin{pmatrix}\n"
"   \\cos(\\theta_0)&-\\sin(\\theta_0)&0\\\\\n"
"   \\sin(\\theta_0)&\\cos(\\theta_0)&0\\\\\n"
"   0&0&1\\end{pmatrix}\n"
"\\begin{pmatrix}\n"
"   \\Delta x_c\\\\\n"
"   \\Delta x_\\perp\\\\\n"
"   \\varphi\n"
"\\end{pmatrix}"
msgstr ""
"\\Inicio{pmatrix}\n"
"   \\Delta x\n"
"   \\Delta y\n"
"   \\varphi\n"
"\\fin{pmatrix} =\n"
"\\Inicio{pmatrix}\n"
"   \\cos(\\theta_0)&amp;-\\sin(\\theta_0)&amp;0\\\\\n"
"   \\sin(\\theta_0)&amp;\\cos(\\theta_0)&amp;0\\\\\n"
"   0&amp;0&amp;1 fin{pmatrix}\n"
"\\Inicio{pmatrix}\n"
"   \\Delta x_c\n"
"   \\delta x-perp\n"
"   \\varphi\n"
"\\fin{pmatrix}"

#: ../../gm0/source/docs/software/concepts/odometry.rst:106
msgid "From this, we can calculate our field-relative change in pose:"
msgstr ""
"A partir de ahí, podemos calcular nuestro cambio de pose relativo al campo:"

#: ../../gm0/source/docs/software/concepts/odometry.rst:108
msgid ""
"\\begin{pmatrix}\n"
"   \\Delta x \\\\\n"
"   \\Delta y \\\\\n"
"   \\varphi\n"
"\\end{pmatrix} =\n"
"\\begin{pmatrix}\n"
"   \\Delta x_c \\cos(\\theta_0) - \\Delta x_\\perp \\sin(\\theta_0) \\\\\n"
"   \\Delta x_c \\sin(\\theta_0) + \\Delta x_\\perp \\cos(\\theta_0)\\\\\n"
"   \\varphi\n"
"\\end{pmatrix}"
msgstr ""
"\\Inicio{pmatrix}\n"
"   \\Delta x\n"
"   \\Delta y\n"
"   \\varphi\n"
"\\fin{pmatrix} =\n"
"\\Inicio{pmatrix}\n"
"   \\delta x_c \\cos(\\theta_0) - delta x_\\perp \\sin(\\theta_0) \\\n"
"   \\delta x_c sin (zeta_0) + delta x_perp sin (zeta_0)\n"
"   \\VARPHI\n"
"\\Fin{pmatrix}"

#: ../../gm0/source/docs/software/concepts/odometry.rst:121
msgid ""
"This method of approximating position is known as Euler integration, but we "
"are using it for strict pose deltas instead of integrating the velocity "
"(essentially, this is a very simplified version of the original theory)."
msgstr ""
"Este método de aproximación de la posición se conoce como integración de "
"Euler, pero lo estamos utilizando para deltas de pose estrictos en lugar de "
"integrar la velocidad (en esencia, se trata de una versión muy simplificada "
"de la teoría original)."

#: ../../gm0/source/docs/software/concepts/odometry.rst:123
msgid ""
"This is for advanced programmers; while implementing this from scratch is a "
"great learning exercise, it is likely not the optimal way to get the best "
"auto. There are several `resources <#resources-for-odometry>`_ out there for"
" producing great, well-tested, and easy-to-implement odometry."
msgstr ""
"Esto es para programadores avanzados; mientras que implementar esto desde "
"cero es un gran ejercicio de aprendizaje, probablemente no sea la forma "
"óptima de obtener el mejor auto. Hay varios `recursos <#resources-for-"
"odometry>`_ por ahí para producir una gran odometría, bien probada y fácil "
"de implementar."

#: ../../gm0/source/docs/software/concepts/odometry.rst:126
msgid "Odometry Pseudocode"
msgstr "Pseudocódigo de odometría"

#: ../../gm0/source/docs/software/concepts/odometry.rst:151
msgid "Using Pose Exponentials"
msgstr "Uso de exponenciales de pose"

#: ../../gm0/source/docs/software/concepts/odometry.rst:153
msgid ""
"This method uses differential equations to solve the nonlinear position of "
"the robot given constant curvature. Euler integration assumes that the robot"
" follows a straight path between updates, which can lead to inaccurate "
"approximations when traveling around curves. If you are interested in the "
"math itself, we recommend you check out `this book "
"<https://file.tavsys.net/control/controls-engineering-in-frc.pdf>`_ for "
"FRC\\ |reg| controls."
msgstr ""
"Este método utiliza ecuaciones diferenciales para resolver la posición no "
"lineal del robot dada una curvatura constante. La integración de Euler asume"
" que el robot sigue una trayectoria recta entre actualizaciones, lo que "
"puede conducir a aproximaciones inexactas cuando se viaja alrededor de "
"curvas. Si usted está interesado en las matemáticas en sí, le recomendamos "
"que consulte `este libro <https://file.tavsys.net/control/controls-"
"engineering-in-frc.pdf>`_ para FRC\\ |reg| controles."

#: ../../gm0/source/docs/software/concepts/odometry.rst:155
msgid ""
"We'll treat the way it is solved in this page as a black box, and derive the"
" formula by implementing a correction for this nonlinear curvature into our "
"Euler integration robot-relative deltas equation:"
msgstr ""
"Trataremos la forma en que se resuelve en esta página como una caja negra, y"
" derivaremos la fórmula implementando una corrección para esta curvatura no "
"lineal en nuestra ecuación de deltas relativos al robot de integración de "
"Euler:"

#: ../../gm0/source/docs/software/concepts/odometry.rst:157
msgid ""
"\\begin{pmatrix}\n"
"\\Delta x \\\\ \\Delta y \\\\ \\varphi\n"
"\\end{pmatrix} =\n"
"\\begin{pmatrix}\n"
"\\cos(\\theta_0)&-\\sin(\\theta_0)&0\\\\\n"
"\\sin(\\theta_0)&\\cos(\\theta_0)&0\\\\\n"
"0&0&1\\end{pmatrix}\n"
"\\begin{pmatrix}\n"
"\\frac{\\sin(\\varphi)}{\\varphi}&\\frac{\\cos(\\varphi)-1}{\\varphi}&0\\\\\n"
"\\frac{1-\\cos(\\varphi)}{\\varphi}&\\frac{\\sin(\\varphi)}{\\varphi}&0\\\\\n"
"0&0&1\\end{pmatrix}\n"
"\\begin{pmatrix}\n"
"\\Delta x_c\\\\ \\Delta x_\\perp\\\\ \\varphi\n"
"\\end{pmatrix}"
msgstr ""
"\\begin{pmatrix}\n"
"\\Delta x \\\\ \\Delta y \\\\ \\varphi\n"
"\\end{pmatrix} =\n"
"\\begin{pmatrix}\n"
"\\cos(\\theta_0)&-\\sin(\\theta_0)&0\\\\\n"
"\\sin(\\theta_0)&\\cos(\\theta_0)&0\\\\\n"
"0&0&1\\end{pmatrix}\n"
"\\begin{pmatrix}\n"
"\\frac{\\sin(\\varphi)}{\\varphi}&\\frac{\\cos(\\varphi)-1}{\\varphi}&0\\\\\n"
"\\frac{1-\\cos(\\varphi)}{\\varphi}&\\frac{\\sin(\\varphi)}{\\varphi}&0\\\\\n"
"0&0&1\\end{pmatrix}\n"
"\\begin{pmatrix}\n"
"\\Delta x_c\\\\ \\Delta x_\\perp\\\\ \\varphi\n"
"\\end{pmatrix}"

#: ../../gm0/source/docs/software/concepts/odometry.rst:175
msgid "Resources for Odometry"
msgstr "Recursos para la odometría"

#: ../../gm0/source/docs/software/concepts/odometry.rst:177
msgid ""
"There are several great resources out there for odometry. We highly "
"recommend `Road Runner <https://acme-robotics.gitbook.io/road-runner/>`_. "
"For the math behind Road Runner (which utilizes pose exponentials), you can "
"also read `Ryan's paper <https://github.com/acmerobotics/road-"
"runner/blob/master/doc/pdf/Mobile_Robot_Kinematics_for_FTC.pdf>`_. An "
"additional resource for Road Runner is `Learn Road Runner "
"<https://learnroadrunner.com/>`_ which is a step-by-step procedural guide "
"that explains how to work with the `Road Runner quickstart "
"<https://github.com/acmerobotics/road-runner-quickstart>`_."
msgstr ""
"Existen varios recursos excelentes para la odometría. Recomendamos "
"encarecidamente `Road Runner <https://acme-robotics.gitbook.io/road-"
"runner/>`_. Para las matemáticas que hay detrás de Road Runner (que utiliza "
"exponenciales de pose), también puedes leer el artículo de `Ryan "
"<https://github.com/acmerobotics/road-"
"runner/blob/master/doc/pdf/Mobile_Robot_Kinematics_for_FTC.pdf>`_. Un "
"recurso adicional para Road Runner es `Learn Road Runner "
"<https://learnroadrunner.com/>`_ que es una guía de procedimiento paso a "
"paso que explica cómo trabajar con el `Road Runner quickstart "
"<https://github.com/acmerobotics/road-runner-quickstart>`_."

#: ../../gm0/source/docs/software/concepts/odometry.rst:179
msgid ""
"We also recommend `Tyler's book <https://file.tavsys.net/control/controls-"
"engineering-in-frc.pdf>`_ as it goes into great detail about various "
"controls in *FIRST*\\ |reg| robotics."
msgstr ""
"También recomendamos el libro de `Tyler "
"<https://file.tavsys.net/control/controls-engineering-in-frc.pdf>`_ ya que "
"entra en gran detalle sobre varios controles en *FIRST* |reg| robótica."

#: ../../gm0/source/docs/software/concepts/odometry.rst:181
msgid ""
"If you're using other resources, it is important that you do not use ones "
"that utilize Euler integration as it is less optimal for real life "
"approximations of robot pose."
msgstr ""
"Si utiliza otros recursos, es importante que no utilice los que utilizan la "
"integración de Euler, ya que es menos óptima para las aproximaciones reales "
"de la pose del robot."

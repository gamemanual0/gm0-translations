# SOME DESCRIPTIVE TITLE.
# Copyright (C) Game Manual 0 Contributors |  Hosting Graciously Provided By //Copperforge
# This file is distributed under the same license as the Game Manual 0 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Younes Djafri, 2025
# Aaraf Chy, 2025
# Dusto867@gmail.com, 2025
# Justine, 2025
# Lyna Alem, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Game Manual 0 0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-08 04:28+0000\n"
"PO-Revision-Date: 2022-08-16 05:18+0000\n"
"Last-Translator: Lyna Alem, 2025\n"
"Language-Team: French (Canada) (https://app.transifex.com/gamemanual0/teams/148648/fr_CA/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: fr_CA\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % 1000000 == 0 ? 1 : 2;\n"

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:4
msgid "Reading and Writing to Hardware"
msgstr "Lire et écrire sur du matériel"

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:6
msgid ""
"When using the FTC\\ |reg| SDK, there are a variety of built in hardware "
"classes which can be used to communicate with hardware on the robot such as "
"DC Motors, :term:`Servos <Servo>`, and Sensors."
msgstr ""
"Lorsque vous utilisez le SDK FTC\\ |reg|, il existe une variété de classes "
"matérielles intégrées qui peuvent être utilisées pour communiquer avec le "
"matériel du robot, comme les moteurs CC, :term:`Servos <Servo>`, et les "
"capteurs."

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:9
msgid "Creating and Instantiating Hardware Objects"
msgstr "Création et instanciation d'objets matériels"

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:11
msgid ""
"The first thing required to properly create an object is to import its "
"class. In Android Studio, if the class is referenced without being imported "
"Alt+Enter can be pressed to automatically import it. After it is imported, "
"the next step is to create the object::"
msgstr ""
"La première chose à faire pour créer correctement un objet est d'importer sa"
" classe. Dans Android Studio, si la classe est référencée sans être "
"importée, il est possible d'appuyer sur Alt+Enter pour l'importer "
"automatiquement. Une fois la classe importée, l'étape suivante consiste à "
"créer l'objet: :"

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:15
msgid ""
"After the object is created, it must be instantiated. Part of the ``OpMode``"
" superclass is something called ``hardwareMap``. ``hardwareMap`` is used in "
"the FTC SDK to instantiate objects rather than calling a constructor."
msgstr ""
"Une fois l'objet créé, il doit être instancié. Une partie de la superclasse "
"``OpMode`` est appelée ``hardwareMap``. ``hardwareMap`` est utilisé dans le "
"SDK FTC pour instancier les objets plutôt que d'appeler un constructeur."

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:17
msgid ""
"It contains all of the information entered into the configuration on the "
"Robot Controller, such as names of hardware and what port it is plugged "
"into. Here is an example of instantiating the motor we created above::"
msgstr ""
"Il contient toutes les informations saisies dans la configuration du "
"contrôleur de robot, telles que les noms du matériel et le port sur lequel "
"il est branché. Voici un exemple d'instanciation du moteur que nous avons "
"créé ci-dessus: :"

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:21
msgid ""
"Whatever sensor you are using, you will pass that class into the spot where "
"``DcMotor.class`` is. For example, if liftMotor was a Servo, ``Servo.class``"
" would be passed instead."
msgstr ""
"Quel que soit le capteur que vous utilisez, vous passerez cette classe à "
"l'endroit où se trouve ``DcMotor.class``. Par exemple, si liftMotor était un"
" Servo, ``Servo.class`` serait passé à la place."

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:23
msgid ""
"For the second argument, you pass whatever the device is named in the Robot "
"Controller configuration. ``hardwareMap`` will then go find what port the "
"device with that name is plugged into, which allows the hardware to be "
"accessed."
msgstr ""
"Pour le second argument, vous passez le nom du périphérique dans la "
"configuration du contrôleur de robot. ``hardwareMap`` va alors chercher le "
"port sur lequel le périphérique portant ce nom est branché, ce qui permet "
"d'accéder au matériel."

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:26
msgid "Examples of Using Common Hardware Components"
msgstr "Exemples d'utilisation de composants matériels communs"

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:29
msgid "DC Motor"
msgstr "Moteur à courant continu"

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:39
msgid ""
"After a ``DcMotor`` is instantiated, there are a few variables you can set "
"to affect how the DC Motor runs. The first of these is direction::"
msgstr ""
"Après l'instanciation d'un ``DcMotor``, il y a quelques variables que vous "
"pouvez définir pour affecter la façon dont le moteur DC fonctionne. La "
"première d'entre elles est la direction: :"

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:44
msgid ""
"Changing the direction of the motor does exactly what should be expected, it"
" changes the direction. If a power of 1 is applied to the motor while it is "
"in forward mode, it will turn one direction. If it is in reverse, a power of"
" 1 will spin it in the other direction. If you face the shaft of the motor "
"towards you, forward is counterclockwise (with the exception of NeveRest "
"motors)."
msgstr ""
"Le changement de direction du moteur fait exactement ce que l'on attend de "
"lui : il change de direction. Si une puissance de 1 est appliquée au moteur "
"lorsqu'il est en mode marche avant, il tournera dans un sens. S'il est en "
"marche arrière, une puissance de 1 le fera tourner dans l'autre sens. Si "
"vous faites face à l'arbre du moteur, la marche avant est dans le sens "
"inverse des aiguilles d'une montre (à l'exception des moteurs NeveRest)."

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:46
msgid "Next, there are two zero power behaviors that can be adjusted::"
msgstr ""
"Ensuite, il y a deux comportements de puissance nulle qui peuvent être "
"ajustés: :"

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:51
msgid ""
"Changing this variable affects how the DC Motor behaves while a power of 0 "
"is applied. ``BRAKE`` will cause the motor to try and slow itself down if it"
" is moving (it will NOT cause the motor to hold its position if not already "
"moving), while ``FLOAT`` causes the motor to glide to a stop, letting "
"friction do all the work."
msgstr ""
"La modification de cette variable affecte le comportement du moteur à "
"courant continu lorsqu'une puissance de 0 est appliquée. ``BRAKE`` fera en "
"sorte que le moteur essaie de se ralentir s'il est en mouvement (il ne fera "
"PAS en sorte que le moteur maintienne sa position s'il n'est pas déjà en "
"mouvement), tandis que ``FLOTTANT`` fera en sorte que le moteur glisse "
"jusqu'à l'arrêt, laissant la friction faire tout le travail."

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:53
msgid ""
"Finally, there are four different run modes that can be used with DC motors:"
" ::"
msgstr ""
"Enfin, il existe quatre modes de fonctionnement différents qui peuvent être "
"utilisés avec les moteurs à courant continu : : :"

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:61
msgid ""
"It is important to note that encoder values can be read in any of these "
"modes provided an encoder is properly plugged in. These modes just change "
"how the motor reacts to these encoder values. `The REV Robotics "
"documentation has an explanation of all four run modes "
"<https://docs.revrobotics.com/duo-control/programming/using-encoder-"
"feedback#choosing-a-motor-mode>`_."
msgstr ""
"Il est important de noter que les valeurs du codeur peuvent être lues dans "
"n'importe lequel de ces modes, à condition qu'un codeur soit correctement "
"branché. Ces modes modifient simplement la façon dont le moteur réagit à ces"
" valeurs d'encodage. La documentation de REV Robotics contient une "
"explication des quatre modes de fonctionnement "
"<https://docs.revrobotics.com/duo-control/programming/using-encoder-"
"feedback#choosing-a-motor-mode>`_."

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:63
msgid ""
"``RUN_TO_POSITION`` can be a convenient way to control a single-motor "
"mechanism, as it offloads all control work; however, since every motor is "
"dealt with independently, it is inadvisable to use this on mechanisms with "
"multiple motors, especially drivetrains."
msgstr ""
"``RUN_TO_POSITION`` peut être un moyen pratique de contrôler un mécanisme à "
"un seul moteur, car il décharge tout le travail de contrôle ; cependant, "
"comme chaque moteur est traité indépendamment, il est déconseillé de "
"l'utiliser sur des mécanismes à plusieurs moteurs, en particulier sur les "
"chaînes cinématiques."

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:66
msgid "Encoders"
msgstr "Encodeurs"

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:68
msgid "Term"
msgstr "Définition"

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:71
msgid "Encoder"
msgstr "Encodeur"

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:73
msgid ""
"An encoder refers to a device that tracks (generally) rotational movement "
"around an axis."
msgstr ""
"Un encodeur est un dispositif qui suit (généralement) un mouvement de "
"rotation autour d'un axe."

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:75
msgid ""
"There are both absolute and relative encoders. An absolute encoder will "
"report at exactly what angle the shaft is compared to its absolute \"zero\"."
" A relative encoder will report how far the :term:`shaft <Shaft>` has "
"rotated since it started tracking (for example, when autonomous starts). "
"Relative encoders will have a quadrature output, whereas absolute encoders "
"generally have analog or i2c outputs."
msgstr ""
"Il existe des encodeurs absolus et des codeurs relatifs. Un encodeur absolu "
"indique exactement l'angle de rotation de l'arbre par rapport à son \"zéro\""
" absolu. Un encodeur relatif indique la distance à laquelle l'arbre "
":term:`shaft <Shaft>` a tourné depuis le début du suivi (par exemple, "
"lorsque l'autonomie commence). Les encodeurs relatifs ont une sortie en "
"quadrature, tandis que les encodeurs absolus ont généralement des sorties "
"analogiques ou i2c."

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:77
msgid ""
"Encoders are used to help find the position of where the robot, or one of "
"its mechanisms, is."
msgstr ""
"Les encodeurs sont utilisés pour déterminer la position du robot ou de l'un "
"de ses mécanismes."

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:79
msgid ""
"While all FTC legal motors contain built in relative quadrature encoders, "
"they must be wired separately and are not required for use. External "
"encoders may be used and plugged into an encoder port so long as they use "
"the quadrature communication protocol."
msgstr ""
"Bien que tous les moteurs légaux de la FTC contiennent des encodeurs "
"relatifs en quadrature intégrés, ils doivent être câblés séparément et ne "
"sont pas nécessaires à leur utilisation. Des encodeurs externes peuvent être"
" utilisés et branchés sur un port de codeur à condition qu'ils utilisent le "
"protocole de communication en quadrature."

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:81
msgid ""
"Accessing encoders requires calling one method on the DcMotor object, "
"``getCurrentPosition()``, which returns the current position of the encoder "
"plugged into the port. This number may be arbitrary at the beginning of an "
"opmode, and is not reset to 0 unless ``STOP_AND_RESET_ENCODERS`` is used or "
"power is cycled to the expansion hub."
msgstr ""
"L'accès aux encodeurs nécessite d'appeler une méthode sur l'objet DcMotor, "
"``getCurrentPosition()``, qui renvoie la position actuelle de l'encodeur "
"branché sur le port. Ce nombre peut être arbitraire au début d'un mode op, "
"et n'est pas remis à 0 à moins que ``STOP_AND_RESET_ENCODERS`` ne soit "
"utilisé ou que l'alimentation du hub d'expansion ne soit cyclique."

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:83
msgid ""
"There is no real standardized terminology when dealing with quadrature "
"encoders. The SDK uses \"CPR\" or Counts Per Revolution by default,. You may"
" also see some datasheets list \"PPR\" or Pulses per Revolution. One pulse "
"can be equivalent to anywhere from 1 to 4 SDK \"counts\". Be careful when "
"reading datasheets!"
msgstr ""
"Il n'existe pas vraiment de terminologie normalisée pour les encodeurs en "
"quadrature. Le SDK utilise par défaut \"CPR\" ou \"Counts Per Revolution\". "
"Certaines fiches techniques indiquent également \"PPR\" ou Impulsions par "
"Révolution. Une impulsion peut être équivalente à 1 à 4 \"comptes\" du SDK. "
"Soyez prudent lorsque vous lisez des fiches techniques !"

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:85
msgid ""
"Encoders with high numbers of Counts per Revolution, such as the REV Through"
" Bore Encoder, can lose steps if plugged into ports 1 or 2. In addition, "
"calls to ``getVelocity()`` on a DcMotorEx object may overflow with high "
"counts per revolution encoders, due to the returned number only being a 16 "
"bit signed integer."
msgstr ""
"Les encodeurs ayant un nombre élevé de comptes par révolution, tels que le "
"codeur à alésage traversant REV, peuvent perdre des pas s'ils sont branchés "
"sur les ports 1 ou 2. De plus, les appels à ``getVelocity()`` sur un objet "
"DcMotorEx peuvent déborder avec des encodeurs à grand nombre de comptes par "
"révolution, car le nombre retourné n'est qu'un entier signé de 16 bits."

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:88
msgid "Servo"
msgstr "Servo"

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:94
msgid ""
"After instantiating a ``Servo``, there are two main functions that can be "
"called: ``setPosition()`` and ``getPosition()``. ::"
msgstr ""
"Après avoir instancié un ``Servo``, il y a deux fonctions principales qui "
"peuvent être appelées : ``setPosition()`` et ``getPosition()``. : :"

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:99
msgid ""
"``setPosition()`` sets the position of the :term:`servo <Servo>`. The SDK "
"will use a built-in control loop with the :term:`servo's <Servo>` "
"potentiometer to drive the :term:`servo <Servo>` to that position and hold "
"that position. ``setPosition()`` takes in a double between 0 and 1, where 0 "
"is the :term:`servo's <Servo>` lower limit of rotation and 1 is the "
":term:`servo's <Servo>` upper limit of rotation. Everything between is "
"directly proportional, so 0.5 is the middle, 0.75 is 3/4 the way up, etc."
msgstr ""
"``setPosition()`` définit la position du :term:`servo <Servo>`. Le SDK "
"utilisera une boucle de contrôle intégrée avec le potentiomètre "
":term:`servo's <Servo>` pour conduire le :term:`servo <Servo>` à cette "
"position et la maintenir. ``setPosition()`` prend un double entre 0 et 1, où"
" 0 est la limite inférieure de rotation du :term:`servo <Servo>` et 1 est la"
" limite supérieure de rotation du :term:`servo <Servo>`. Tout ce qui se "
"trouve entre les deux est directement proportionnel, donc 0,5 est le milieu,"
" 0,75 est les 3/4 du chemin vers le haut, etc."

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:101
msgid ""
"``getPosition()`` does not return the :term:`servo's <Servo>` current "
"position, rather its current target position. If a variable for the "
":term:`servo's <Servo>` current target position is stored properly, this "
"function should never be needed."
msgstr ""
"``getPosition()`` ne renvoie pas la position actuelle du :term:`servo "
"<Servo>`, mais plutôt sa position cible actuelle. Si une variable pour la "
"position actuelle du :term:`servo <Servo>` est stockée correctement, cette "
"fonction ne devrait jamais être nécessaire."

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:104
msgid "Continuous Rotation Servo"
msgstr "Servo à rotation continue"

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:110
msgid ""
"A CRServo has one main method; ``setPower()``. This works very similarly to "
"``DcMotor`` 's ``setPower()``, meaning that passing it 0 makes it stop, "
"passing it 1 makes it go forward at full speed, passing it -1 makes it go "
"backwards at full speed, and everything in between. ::"
msgstr ""
"Un CRServo a une méthode principale, ``setPower()``. Son fonctionnement est "
"très similaire à celui de ``setPower()`` de ``DcMotor``, ce qui signifie que"
" lui passer 0 le fait s'arrêter, lui passer 1 le fait avancer à pleine "
"vitesse, lui passer -1 le fait reculer à pleine vitesse, et tout ce qui se "
"trouve entre les deux... : :"

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:115
msgid "Digital IO"
msgstr "Digital IO"

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:121
msgid ""
"A DigitalChannel has a couple main methods. ``setMode()`` is used to set the"
" port as either an OUTPUT or INPUT port, ``getState()`` returns the current "
"state of the port (only works in INPUT mode), and ``setState()`` sets the "
"state of the port (only works in OUTPUT mode)"
msgstr ""
"Un DigitalChannel possède quelques méthodes principales. ``setMode()`` est "
"utilisée pour définir le port en tant que port OUTPUT ou INPUT, "
"``getState()` retourne l'état actuel du port (ne fonctionne qu'en mode "
"INPUT), et ``setState()` définit l'état du port (ne fonctionne qu'en mode "
"OUTPUT)."

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:123
msgid "Digital ports start by default in INPUT mode"
msgstr "Les ports numériques démarrent par défaut en mode INPUT"

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:125
msgid ""
"Digital ports are pulled UP to prevent floating. This means that there is a "
"resistor between the port and 3.3V so the port reads HIGH by default when "
"nothing is connected. As a result digital devices MUST connect the digital "
"pin to ground when closed, then leave it unconnected when open. For limit "
"switches, this means connecting one lead to ground and the other to the "
"digital port. **Connecting this wrong (connecting 3.3V to the digital port) "
"may cause instability and can cause your expansion hub to crash**"
msgstr ""
"Les ports numériques sont tirés vers le haut pour éviter le flottement. Cela"
" signifie qu'il y a une résistance entre le port et 3,3 V, de sorte que le "
"port se lit HAUT par défaut lorsque rien n'est connecté. Par conséquent, les"
" dispositifs numériques DOIVENT connecter la broche numérique à la terre "
"lorsqu'elle est fermée, puis la laisser non connectée lorsqu'elle est "
"ouverte. Pour les interrupteurs de fin de course, cela signifie qu'il faut "
"connecter un fil à la terre et l'autre au port numérique. **Un mauvais "
"branchement (connexion de 3,3 V au port numérique) peut provoquer une "
"instabilité et faire planter votre concentrateur d'expansion**."

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:128
msgid "Analog Input"
msgstr "Entrée analogique"

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:134
msgid ""
"An ``AnalogInput`` has one main method: ``getVoltage()`` which is used to "
"get the current input voltage to the port."
msgstr ""
"Une ``AnalogInput`` a une méthode principale : ``getVoltage()`` qui est "
"utilisée pour obtenir la tension d'entrée actuelle sur le port."

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:136
msgid ""
"Although ``getMaxVoltage()`` returns 3.3v, the expansion and control hub "
"analog input ports can safely handle up to 5v."
msgstr ""
"Bien que ``getMaxVoltage()`` renvoie 3.3v, les ports d'entrée analogique des"
" concentrateurs d'expansion et de contrôle peuvent en toute sécurité "
"supporter jusqu'à 5v."

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:139
msgid "A Note on Hardware Call Speed"
msgstr "Note sur la vitesse d'appel du matériel"

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:141
msgid ""
"Every hardware call you make, (whether it be setting the power for a motor, "
"setting a :term:`servo <Servo>` position, reading an encoder value, etc.) "
"will take approximately 3 milliseconds to execute, except for I2C calls "
"which can take upwards of 7ms. This is because behind the scenes, the SDK "
"may need to make multiple hardware calls in order to perform the I2C "
"operation."
msgstr ""
"Chaque appel matériel que vous effectuez (qu'il s'agisse de régler la "
"puissance d'un moteur, de définir une position :term:`servo <Servo>`, de "
"lire une valeur d'encodeur, etc.) prendra environ 3 millisecondes pour être "
"exécuté, à l'exception des appels I2C qui peuvent prendre jusqu'à 7 ms. Cela"
" s'explique par le fait qu'en coulisses, le SDK peut avoir besoin de faire "
"plusieurs appels au matériel pour effectuer l'opération I2C."

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:143
msgid ""
"When using a Control Hub, you may see considerably faster hardware call "
"times because the Control Hub uses a direct UART connection to the Lynx "
"board instead of going through USB and a middle-man FTDI as happens when "
"using a phone."
msgstr ""
"Lorsque vous utilisez un concentrateur de contrôle, vous pouvez constater "
"des temps d'appel matériel considérablement plus rapides car le "
"concentrateur de contrôle utilise une connexion UART directe avec la carte "
"Lynx au lieu de passer par USB et un intermédiaire FTDI comme c'est le cas "
"lorsqu'on utilise un téléphone."

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:145
msgid ""
"These times may seem fast, but they add up quickly. Consider a control loop "
"to drive forward for N encoder counts while maintaining heading using the "
"IMU. This would require 5 normal hardware calls (4 set power + 1 read "
"encoder) and an I2C call (IMU) which means that the loop cycle would take "
"approximately 22ms to execute, and thus run at approximately 45Hz."
msgstr ""
"Ces temps peuvent sembler rapides, mais ils s'additionnent rapidement. "
"Prenons l'exemple d'une boucle de contrôle permettant d'avancer pour N "
"comptes codeur tout en maintenant le cap à l'aide de l'IMU. Cela "
"nécessiterait 5 appels matériels normaux (4 réglages de puissance + 1 "
"lecture de codeur) et un appel I2C (IMU), ce qui signifie que le cycle de la"
" boucle prendrait environ 22 ms pour s'exécuter, et donc fonctionnerait à "
"environ 45 Hz."

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:147
msgid ""
"This means that it is critical to minimize the amount of hardware calls you "
"make in order to keep your control loops running fast. For instance, do not "
"read a sensor more than once per loop. Instead, read it once and store the "
"value to a variable if you need to use it again at other points in the same "
"loop cycle."
msgstr ""
"Cela signifie qu'il est essentiel de minimiser le nombre d'appels au "
"matériel que vous effectuez afin que vos boucles de contrôle fonctionnent "
"rapidement. Par exemple, ne lisez pas un capteur plus d'une fois par boucle."
" Au contraire, lisez-le une fois et stockez la valeur dans une variable si "
"vous avez besoin de l'utiliser à nouveau à d'autres moments du même cycle de"
" boucle."

#: ../../gm0/source/docs/software/getting-started/common-hardware-components.rst:149
msgid ""
"Using a bulk read hardware call can help with this problem. A bulk read "
"takes the same 3ms to execute as any other normal hardware call, but it "
"returns far more data. In order to be able to use bulk reads, you must be "
"running SDK v5.4 or higher. See :doc:`/docs/software/tutorials/bulk-reads` "
"for more information"
msgstr ""
"L'utilisation d'un appel matériel de lecture en bloc peut résoudre ce "
"problème. L'exécution d'une lecture en bloc prend les mêmes 3 ms que "
"n'importe quel autre appel matériel normal, mais elle renvoie beaucoup plus "
"de données. Pour pouvoir utiliser les lectures en bloc, vous devez utiliser "
"le SDK v5.4 ou une version ultérieure. Voir "
":doc:`/docs/software/tutorials/bulk-reads` pour plus d'informations."

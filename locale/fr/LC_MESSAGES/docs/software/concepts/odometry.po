# SOME DESCRIPTIVE TITLE.
# Copyright (C) Game Manual 0 Contributors |  Hosting Graciously Provided By //Copperforge
# This file is distributed under the same license as the Game Manual 0 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Younes Djafri, 2025
# Dusto867@gmail.com, 2025
# Justine, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Game Manual 0 0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-15 04:28+0000\n"
"PO-Revision-Date: 2022-08-16 05:18+0000\n"
"Last-Translator: Justine, 2025\n"
"Language-Team: French (Canada) (https://app.transifex.com/gamemanual0/teams/148648/fr_CA/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: fr_CA\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % 1000000 == 0 ? 1 : 2;\n"

#: ../../gm0/source/docs/software/concepts/odometry.rst:4
msgid "Odometry"
msgstr "Odométrie"

#: ../../gm0/source/docs/software/concepts/odometry.rst:6
msgid ""
"Odometry is a form of localization that uses data from sensors like encoders"
" to derive an estimated position relative to a starting point. Localization "
"is a means for being able to locate the position of the bot at some point in"
" time. Odometry is especially useful in autonomous programs because it "
"allows for easier implementation of different tasks on the field due to "
"understanding one's position."
msgstr ""
"L'odométrie est une forme de localisation qui utilise des données provenant "
"de capteurs tels que des encodeurs pour obtenir une position estimée par "
"rapport à un point de départ. La localisation est un moyen de localiser la "
"position du robot à un moment donné. L'odométrie est particulièrement utile "
"dans les programmes autonomes car elle permet de faciliter l'exécution de "
"différentes tâches sur le terrain grâce à la compréhension de sa propre "
"position."

#: ../../gm0/source/docs/software/concepts/odometry.rst:9
msgid "Pose"
msgstr "Pose"

#: ../../gm0/source/docs/software/concepts/odometry.rst:11
msgid ""
"We refer to pose, which is the position of some body (like a bot), normally "
"in the context two-dimensional space, as the movement of the robot is "
"generally constrained to a single plane. We notate the robot's pose as "
":math:`\\vec{x}`. A pose contains two entries: the robot's position and "
"heading; position is generally in Cartesian coordinates, so the pose can be "
"represented with :math:`x`, :math:`y`, and :math:`\\theta`. A \"heading\" is"
" a term for the direction towards which the front of the robot is facing. "
"Because of this, the robot's coordinate frame is set up such that the global"
" x-axis is lined up with the 0 heading."
msgstr ""
"Nous nous référons à la pose, qui est la position d'un corps (comme un "
"robot), normalement dans le contexte d'un espace bidimensionnel, puisque le "
"mouvement du robot est généralement contraint à un seul plan. Nous notons la"
" pose du robot comme :math:`\\vec{x}`. Une pose contient deux entrées : la "
"position et le cap du robot ; la position est généralement en coordonnées "
"cartésiennes, de sorte que la pose peut être représentée par :math:`x`, "
":math:`y`, et :math:`\\theta`. Un \"cap\" est un terme qui désigne la "
"direction vers laquelle l'avant du robot est orienté. Pour cette raison, le "
"cadre de coordonnées du robot est configuré de manière à ce que l'axe x "
"global soit aligné sur le cap 0."

#: ../../gm0/source/docs/software/concepts/odometry.rst:18
msgid "The directional axes of the robot with respect to its body"
msgstr "Les axes directionnels du robot par rapport à son corps"

#: ../../gm0/source/docs/software/concepts/odometry.rst:18
msgid ""
"`Road Runner Coordinate Frame Documentation <https://acme-"
"robotics.gitbook.io/road-runner/tour/coordinate-frame>`_"
msgstr ""
"`Road Runner Coordinate Frame Documentation <https://acme-"
"robotics.gitbook.io/road-runner/tour/coordinate-frame>`_"

#: ../../gm0/source/docs/software/concepts/odometry.rst:20
msgid ""
"We can refer to the current pose (:math:`\\vec{x}_0`) of the robot as "
":math:`\\begin{pmatrix} x_0 \\\\ y_0 \\\\ \\theta_0 \\end{pmatrix}`. This is"
" just fancy notation for a point on the field :math:`(x_0, y_0)` with a "
"specified orientation of the robot--the heading :math:`\\theta_0`. A pose "
"generally has some beginning origin in the coordinate frame."
msgstr ""
"Nous pouvons nous référer à la position actuelle (:math:\\vec{x}_0`) du "
"robot comme :math:\\begin{pmatrix} x_0 \\\\ y_0 \\ \\theta_0 "
"\\end{pmatrix}`. C'est juste une notation fantaisiste pour un point sur le "
"champ :math:`(x_0, y_0)` avec une orientation spécifiée du robot - le titre "
":math:\\theta_0`. Une pose a généralement un point d'origine dans le cadre "
"de coordonnées."

#: ../../gm0/source/docs/software/concepts/odometry.rst:23
msgid "Updating the Pose"
msgstr "Mise à jour de la pose"

#: ../../gm0/source/docs/software/concepts/odometry.rst:25
msgid ""
"The change in pose over some very small amount of time is :math:`\\Delta "
"\\vec{x}`. The difference in time between the current pose and the last pose"
" should be as small as possible to improve the approximations for the math. "
"Teams should update their robot pose every cycle of their control loop."
msgstr ""
"Le changement de pose sur une très petite période de temps est :math:\\Delta"
" \\vec{x}`. La différence de temps entre la pose actuelle et la dernière "
"pose doit être aussi petite que possible pour améliorer les approximations "
"mathématiques. Les équipes doivent mettre à jour la position de leur robot à"
" chaque cycle de leur boucle de contrôle."

#: ../../gm0/source/docs/software/concepts/odometry.rst:27
msgid ""
"Updating the pose is as simple as adding the transformed change to the "
"previous pose where :math:`\\varphi = \\Delta\\theta`"
msgstr ""
"La mise à jour de la pose est aussi simple que l'ajout du changement "
"transformé à la pose précédente où :math:``varphi = \\Delta\\theta``"

#: ../../gm0/source/docs/software/concepts/odometry.rst:29
msgid ""
"\\begin{pmatrix}\n"
"   x \\\\\n"
"   y \\\\\n"
"   \\theta\n"
"\\end{pmatrix} =\n"
"\\begin{pmatrix}\n"
"   x_0 \\\\\n"
"   y_0\\\\\n"
"   \\theta_0\n"
"\\end{pmatrix} +\n"
"\\begin{pmatrix}\n"
"   \\Delta x \\\\\n"
"   \\Delta y \\\\\n"
"   \\varphi\n"
"\\end{pmatrix}"
msgstr ""
"\\begin{pmatrix}\n"
"   x \\\\\n"
"   y \\\\\n"
"   \\theta\n"
"\\end{pmatrix} =\n"
"\\begin{pmatrix}\n"
"   x_0 \\\\\n"
"   y_0\\\\\n"
"   \\theta_0\n"
"\\end{pmatrix} +\n"
"\\begin{pmatrix}\n"
"   \\Delta x \\\\\n"
"   \\Delta y \\\\\n"
"   \\varphi\n"
"\\end{pmatrix}"

#: ../../gm0/source/docs/software/concepts/odometry.rst:47
msgid ""
"The idea of odometry is to use sensor data and math to form an approximation"
" for the robot's pose over time."
msgstr ""
"L'idée de l'odométrie est d'utiliser les données des capteurs et les "
"mathématiques pour former une approximation de la position du robot au fil "
"du temps."

#: ../../gm0/source/docs/software/concepts/odometry.rst:50
msgid "Finding the Change in Position"
msgstr "Détermination du changement de position"

#: ../../gm0/source/docs/software/concepts/odometry.rst:52
msgid ""
"In order to determine the current location of the robot and update its pose,"
" the change must be calculated using data read from the sensors. For a "
"robot, there will be three possible sensors that you can use: two that are "
"parallel with the robot's body in the :math:`x`-direction and one that is "
"aligned with the :math:`y`-direction of movement (perpendicular to the drive"
" wheels)."
msgstr ""
"Afin de déterminer la position actuelle du robot et de mettre à jour sa "
"pose, le changement doit être calculé à l'aide des données lues par les "
"capteurs. Pour un robot, vous pouvez utiliser trois capteurs : deux qui sont"
" parallèles au corps du robot dans la direction :math:`x` et un qui est "
"aligné avec la direction :math:`y` du mouvement (perpendiculaire aux roues "
"motrices)."

#: ../../gm0/source/docs/software/concepts/odometry.rst:55
msgid "Angle and Displacement"
msgstr "Angle et déplacement"

#: ../../gm0/source/docs/software/concepts/odometry.rst:57
msgid ""
"The displacement (or change in position) of the left sensor is "
":math:`\\Delta x_l` and the displacement of the right sensor is "
":math:`\\Delta x_r`. The lateral distance between these two sensors is "
"called the trackwidth, notated as :math:`L`. This is very important for "
"determining angle for turning approximations. This value will need to be "
"tuned, which means tested repeatedly and then brought to some converging "
"value that is close to the actual measurement."
msgstr ""
"Le déplacement (ou changement de position) du capteur gauche est "
":math:`Delta x_l` et le déplacement du capteur droit est :math:\\Delta x_r`."
" La distance latérale entre ces deux capteurs est appelée largeur de la "
"voie, notée :math:`L`. Cette valeur est très importante pour déterminer "
"l'angle des approximations de virage. Cette valeur devra être ajustée, "
"c'est-à-dire testée à plusieurs reprises, puis amenée à une valeur "
"convergente proche de la mesure réelle."

#: ../../gm0/source/docs/software/concepts/odometry.rst:62
msgid "The lateral distance, forward offset, and location of the sensors"
msgstr ""
"La distance latérale, le décalage vers l'avant et l'emplacement des capteurs"

#: ../../gm0/source/docs/software/concepts/odometry.rst:62
msgid ""
"`17508 Rising Tau's 2019/20 Skystone Bot <https://learnroadrunner.com/dead-"
"wheels.html#three-wheel-odometry>`_"
msgstr ""
"`17508 Rising Tau's 2019/20 Skystone Bot <https://learnroadrunner.com/dead-"
"wheels.html#three-wheel-odometry>`_"

#: ../../gm0/source/docs/software/concepts/odometry.rst:64
msgid "Deriving the value of :math:`\\varphi` then becomes simple:"
msgstr "Le calcul de la valeur de :math:``varphi`` devient alors simple :"

#: ../../gm0/source/docs/software/concepts/odometry.rst:66
msgid ""
"\\varphi = \\frac{\\Delta x_l - \\Delta x_r}{L}\n"
"\n"
msgstr ""
"\\varphi = \\frac{\\Delta x_l - \\Delta x_r}{L}\n"
"\n"

#: ../../gm0/source/docs/software/concepts/odometry.rst:68
msgid ""
"To perform later calculations, we need to know the displacement of the robot"
" in the x-direction relative to its center rather than the two parallel "
"sensors. To do this, we take the average to derive :math:`\\Delta x_c`, or "
"the center displacement:"
msgstr ""
"Pour effectuer les calculs ultérieurs, nous avons besoin de connaître le "
"déplacement du robot dans la direction x par rapport à son centre plutôt que"
" par rapport aux deux capteurs parallèles. Pour ce faire, nous prenons la "
"moyenne pour obtenir :math:`\\Delta x_c`, ou le déplacement du centre :"

#: ../../gm0/source/docs/software/concepts/odometry.rst:70
msgid ""
"\\Delta x_c = \\frac{\\Delta x_l + \\Delta x_r}{2}\n"
"\n"
msgstr ""
"\\Delta x_c = \\frac{\\Delta x_l + \\Delta x_r}{2}\n"
"\n"

#: ../../gm0/source/docs/software/concepts/odometry.rst:72
msgid ""
"The final displacement we need before we can determine the change in pose is"
" the horizontal displacement :math:`\\Delta x_\\perp`. This is the "
"displacement of the perpendicular sensor :math:`\\Delta x_h` with a "
"correction for forward offset :math:`F`. In order to get accurate "
"approximations, the forward offset needs to be considered. When the sensor "
"is closer to the back, the offset is negative, but when it is closer to the "
"front, it is positive. This is to account for the change in its position "
"based on point-turns."
msgstr ""
"Le dernier déplacement dont nous avons besoin avant de pouvoir déterminer le"
" changement de pose est le déplacement horizontal :math:\\Delta x_\\perp`. "
"Il s'agit du déplacement du capteur perpendiculaire :math:\\Delta x_h` avec "
"une correction pour le décalage vers l'avant :math:`F`. Pour obtenir des "
"approximations précises, il faut tenir compte du décalage vers l'avant. "
"Lorsque le capteur est plus proche de l'arrière, le décalage est négatif, "
"mais lorsqu'il est plus proche de l'avant, il est positif. Cela permet de "
"prendre en compte le changement de position du capteur en fonction de la "
"rotation des points."

#: ../../gm0/source/docs/software/concepts/odometry.rst:74
msgid "As a result of this, we can define our horizontal displacement as:"
msgstr ""
"Par conséquent, nous pouvons définir notre déplacement horizontal comme suit"
" :"

#: ../../gm0/source/docs/software/concepts/odometry.rst:76
msgid ""
"\\Delta x_\\perp = \\Delta x_h - (F * \\varphi)\n"
"\n"
msgstr ""
"\\Delta x_\\perp = \\Delta x_h - (F * \\varphi)\n"
"\n"

#: ../../gm0/source/docs/software/concepts/odometry.rst:80
msgid ""
"If you do not have perpendicular sensors, which are not required if the "
"robot cannot move in the lateral direction, :math:`\\Delta x_\\perp` is not "
"necessary."
msgstr ""
"Si vous n'avez pas de capteurs perpendiculaires, qui ne sont pas nécessaires"
" si le robot ne peut pas se déplacer dans la direction latérale, "
":math:``Delta x_\\perp` n'est pas nécessaire."

#: ../../gm0/source/docs/software/concepts/odometry.rst:82
msgid "For this value, use 0 if you do not have a horizontal sensor."
msgstr ""
"Pour cette valeur, utilisez 0 si vous n'avez pas de capteur horizontal."

#: ../../gm0/source/docs/software/concepts/odometry.rst:85
msgid "Robot-Relative Deltas"
msgstr "Deltas relatifs aux robots"

#: ../../gm0/source/docs/software/concepts/odometry.rst:87
msgid ""
"Let's come up with a simplified, nonoptimal way to calculate our robot-"
"relative pose deltas which we can then transform into field-relative "
"coordinate changes. To perform this we need to transform the robot-relative "
"deltas via a rotation matrix where we rotate the relative pose difference by"
" the original heading. We can derive the values of :math:`\\Delta x` and "
":math:`\\Delta y`."
msgstr ""
"Proposons une méthode simplifiée et non optimale pour calculer les deltas de"
" pose relatifs du robot, que nous pourrons ensuite transformer en "
"changements de coordonnées relatifs au champ. Pour ce faire, nous devons "
"transformer les deltas relatifs du robot via une matrice de rotation où nous"
" faisons pivoter la différence de pose relative par le cap d'origine. Nous "
"pouvons dériver les valeurs de :math:\\Delta x` et :math:\\Delta y`."

#: ../../gm0/source/docs/software/concepts/odometry.rst:89
msgid ""
"\\begin{pmatrix}\n"
"   \\Delta x \\\\\n"
"   \\Delta y \\\\\n"
"   \\varphi\n"
"\\end{pmatrix} =\n"
"\\begin{pmatrix}\n"
"   \\cos(\\theta_0)&-\\sin(\\theta_0)&0\\\\\n"
"   \\sin(\\theta_0)&\\cos(\\theta_0)&0\\\\\n"
"   0&0&1\\end{pmatrix}\n"
"\\begin{pmatrix}\n"
"   \\Delta x_c\\\\\n"
"   \\Delta x_\\perp\\\\\n"
"   \\varphi\n"
"\\end{pmatrix}"
msgstr ""
"\\begin{pmatrix}\n"
"   \\Delta x \\\\\n"
"   \\Delta y \\\\\n"
"   \\varphi\n"
"\\end{pmatrix} =\n"
"\\begin{pmatrix}\n"
"   \\cos(\\theta_0)&-\\sin(\\theta_0)&0\\\\\n"
"   \\sin(\\theta_0)&\\cos(\\theta_0)&0\\\\\n"
"   0&0&1\\end{pmatrix}\n"
"\\begin{pmatrix}\n"
"   \\Delta x_c\\\\\n"
"   \\Delta x_\\perp\\\\\n"
"   \\varphi\n"
"\\end{pmatrix}"

#: ../../gm0/source/docs/software/concepts/odometry.rst:106
msgid "From this, we can calculate our field-relative change in pose:"
msgstr ""
"À partir de là, nous pouvons calculer notre changement de position relatif "
"au champ :"

#: ../../gm0/source/docs/software/concepts/odometry.rst:108
msgid ""
"\\begin{pmatrix}\n"
"   \\Delta x \\\\\n"
"   \\Delta y \\\\\n"
"   \\varphi\n"
"\\end{pmatrix} =\n"
"\\begin{pmatrix}\n"
"   \\Delta x_c \\cos(\\theta_0) - \\Delta x_\\perp \\sin(\\theta_0) \\\\\n"
"   \\Delta x_c \\sin(\\theta_0) + \\Delta x_\\perp \\cos(\\theta_0)\\\\\n"
"   \\varphi\n"
"\\end{pmatrix}"
msgstr ""
"\\begin{pmatrix}\n"
"   \\Delta x \\\\\n"
"   \\Delta y \\\\\n"
"   \\varphi\n"
"\\end{pmatrix} =\n"
"\\begin{pmatrix}\n"
"   \\Delta x_c \\cos(\\theta_0) - \\Delta x_\\perp \\sin(\\theta_0) \\\\\n"
"   \\Delta x_c \\sin(\\theta_0) + \\Delta x_\\perp \\cos(\\theta_0)\\\\\n"
"   \\varphi\n"
"\\end{pmatrix}"

#: ../../gm0/source/docs/software/concepts/odometry.rst:121
msgid ""
"This method of approximating position is known as Euler integration, but we "
"are using it for strict pose deltas instead of integrating the velocity "
"(essentially, this is a very simplified version of the original theory)."
msgstr ""
"Cette méthode d'approximation de la position est connue sous le nom "
"d'intégration d'Euler, mais nous l'utilisons pour les deltas de pose stricts"
" au lieu d'intégrer la vitesse (il s'agit essentiellement d'une version très"
" simplifiée de la théorie originale)."

#: ../../gm0/source/docs/software/concepts/odometry.rst:123
msgid ""
"This is for advanced programmers; while implementing this from scratch is a "
"great learning exercise, it is likely not the optimal way to get the best "
"auto. There are several `resources <#resources-for-odometry>`_ out there for"
" producing great, well-tested, and easy-to-implement odometry."
msgstr ""
"Ceci s'adresse aux programmeurs avancés ; bien que la mise en œuvre de cette"
" méthode à partir de zéro soit un excellent exercice d'apprentissage, ce "
"n'est probablement pas la meilleure façon d'obtenir la meilleure auto. Il "
"existe plusieurs `ressources <#resources-for-odometry>`_ pour produire une "
"odométrie de qualité, bien testée et facile à mettre en œuvre."

#: ../../gm0/source/docs/software/concepts/odometry.rst:126
msgid "Odometry Pseudocode"
msgstr "Pseudocode d'Odométrie"

#: ../../gm0/source/docs/software/concepts/odometry.rst:151
msgid "Using Pose Exponentials"
msgstr "Utilisation des exponentielles de pose"

#: ../../gm0/source/docs/software/concepts/odometry.rst:153
msgid ""
"This method uses differential equations to solve the nonlinear position of "
"the robot given constant curvature. Euler integration assumes that the robot"
" follows a straight path between updates, which can lead to inaccurate "
"approximations when traveling around curves. If you are interested in the "
"math itself, we recommend you check out `this book "
"<https://file.tavsys.net/control/controls-engineering-in-frc.pdf>`_ for "
"FRC\\ |reg| controls."
msgstr ""
"Cette méthode utilise des équations différentielles pour résoudre la "
"position non linéaire du robot à courbure constante. L'intégration d'Euler "
"suppose que le robot suit une trajectoire rectiligne entre les mises à jour,"
" ce qui peut conduire à des approximations inexactes lorsqu'il se déplace "
"dans des courbes. Si vous êtes intéressé par les mathématiques elles-mêmes, "
"nous vous recommandons de consulter `ce livre "
"<https://file.tavsys.net/control/controls-engineering-in-frc.pdf>`_ pour les"
" commandes FRC\\ |reg|."

#: ../../gm0/source/docs/software/concepts/odometry.rst:155
msgid ""
"We'll treat the way it is solved in this page as a black box, and derive the"
" formula by implementing a correction for this nonlinear curvature into our "
"Euler integration robot-relative deltas equation:"
msgstr ""
"Nous traiterons la façon dont elle est résolue dans cette page comme une "
"boîte noire, et nous déduirons la formule en appliquant une correction pour "
"cette courbure non linéaire dans notre équation d'intégration d'Euler "
"relative aux deltas des robots :"

#: ../../gm0/source/docs/software/concepts/odometry.rst:157
msgid ""
"\\begin{pmatrix}\n"
"\\Delta x \\\\ \\Delta y \\\\ \\varphi\n"
"\\end{pmatrix} =\n"
"\\begin{pmatrix}\n"
"\\cos(\\theta_0)&-\\sin(\\theta_0)&0\\\\\n"
"\\sin(\\theta_0)&\\cos(\\theta_0)&0\\\\\n"
"0&0&1\\end{pmatrix}\n"
"\\begin{pmatrix}\n"
"\\frac{\\sin(\\varphi)}{\\varphi}&\\frac{\\cos(\\varphi)-1}{\\varphi}&0\\\\\n"
"\\frac{1-\\cos(\\varphi)}{\\varphi}&\\frac{\\sin(\\varphi)}{\\varphi}&0\\\\\n"
"0&0&1\\end{pmatrix}\n"
"\\begin{pmatrix}\n"
"\\Delta x_c\\\\ \\Delta x_\\perp\\\\ \\varphi\n"
"\\end{pmatrix}"
msgstr ""
"\\begin{pmatrix}\n"
"\\Delta x \\\\ \\Delta y \\\\ \\varphi\n"
"\\end{pmatrix} =\n"
"\\begin{pmatrix}\n"
"\\cos(\\theta_0)&-\\sin(\\theta_0)&0\\\\\n"
"\\sin(\\theta_0)&\\cos(\\theta_0)&0\\\\\n"
"0&0&1\\end{pmatrix}\n"
"\\begin{pmatrix}\n"
"\\frac{\\sin(\\varphi)}{\\varphi}&\\frac{\\cos(\\varphi)-1}{\\varphi}&0\\\\\n"
"\\frac{1-\\cos(\\varphi)}{\\varphi}&\\frac{\\sin(\\varphi)}{\\varphi}&0\\\\\n"
"0&0&1\\end{pmatrix}\n"
"\\begin{pmatrix}\n"
"\\Delta x_c\\\\ \\Delta x_\\perp\\\\ \\varphi\n"
"\\end{pmatrix}"

#: ../../gm0/source/docs/software/concepts/odometry.rst:175
msgid "Resources for Odometry"
msgstr "Ressources pour l'odométrie"

#: ../../gm0/source/docs/software/concepts/odometry.rst:177
msgid ""
"There are several great resources out there for odometry. We highly "
"recommend `Road Runner <https://acme-robotics.gitbook.io/road-runner/>`_. "
"For the math behind Road Runner (which utilizes pose exponentials), you can "
"also read `Ryan's paper <https://github.com/acmerobotics/road-"
"runner/blob/master/doc/pdf/Mobile_Robot_Kinematics_for_FTC.pdf>`_. An "
"additional resource for Road Runner is `Learn Road Runner "
"<https://learnroadrunner.com/>`_ which is a step-by-step procedural guide "
"that explains how to work with the `Road Runner quickstart "
"<https://github.com/acmerobotics/road-runner-quickstart>`_."
msgstr ""
"Il existe plusieurs ressources excellentes pour l'odométrie. Nous "
"recommandons vivement `Road Runner <https://acme-robotics.gitbook.io/road-"
"runner/>`_. Pour les mathématiques de Road Runner (qui utilisent des "
"exponentielles de pose), vous pouvez également lire l'article de Ryan "
"<https://github.com/acmerobotics/road-"
"runner/blob/master/doc/pdf/Mobile_Robot_Kinematics_for_FTC.pdf>`_. Une "
"ressource supplémentaire pour Road Runner est `Learn Road Runner "
"<https://learnroadrunner.com/>`_ qui est un guide de procédure étape par "
"étape qui explique comment travailler avec le `Road Runner quickstart "
"<https://github.com/acmerobotics/road-runner-quickstart>`_."

#: ../../gm0/source/docs/software/concepts/odometry.rst:179
msgid ""
"We also recommend `Tyler's book <https://file.tavsys.net/control/controls-"
"engineering-in-frc.pdf>`_ as it goes into great detail about various "
"controls in *FIRST*\\ |reg| robotics."
msgstr ""
"Nous recommandons également le livre de Tyler "
"<https://file.tavsys.net/control/controls-engineering-in-frc.pdf>_, car il "
"explique en détail divers systèmes de contrôle en robotique FIRST*\\ |reg|."

#: ../../gm0/source/docs/software/concepts/odometry.rst:181
msgid ""
"If you're using other resources, it is important that you do not use ones "
"that utilize Euler integration as it is less optimal for real life "
"approximations of robot pose."
msgstr ""
"Si vous utilisez d'autres ressources, il est important de ne pas utiliser "
"celles qui utilisent l'intégration d'Euler, car elle est moins optimale pour"
" les approximations réelles de la pose du robot."
